/*----------------------------------------------------------------------------*/
/* The "all-new" TM implementation!                                           */
/* Revised to use the new hybrid/combination TM.                              */
/* Author(s): Kalyan S. Perumalla */
/*----------------------------------------------------------------------------*/
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include "mycompat.h"
#include "fm.h"
#include "tm.h"
#include "rm.h"

/*----------------------------------------------------------------------------*/
extern FILE *tmfp;

/*----------------------------------------------------------------------------*/
struct RVALUE_TYPE_STRUCT
{
    TM_Time val;        /*Timestamp being reduced*/
    TM_TimeQual qual;   /*Timestamp qualification: see TM_TimeQual definition*/
    long nsent, nrecd;  /*Number of timestamped messages sent/received*/
     #if !PLATFORM_WIN
       #if 0 /*XXX Turned off 19Jan11 - will we ever use Windows again?*/
         long padding; /*Compatibility with size generated by Windows compiler*/
       #endif
     #endif
};
/*----------------------------------------------------------------------------*/
static void hton_RVALUE_TYPE( RVALUE_TYPE *v )
    { (v)->nsent = htonl((v)->nsent); (v)->nrecd = htonl((v)->nrecd); }
static void ntoh_RVALUE_TYPE( RVALUE_TYPE *v )
    { (v)->nsent = ntohl((v)->nsent); (v)->nrecd = ntohl((v)->nrecd); }
/*----------------------------------------------------------------------------*/
static RVALUE_TYPE *rv_new( void )
    { return malloc( sizeof( RVALUE_TYPE ) ); }
static void rv_delete( RVALUE_TYPE *v )
    { free( v ); }
static void rv_init(RVALUE_TYPE *a)
    { if(a){ (a)->val = TM_IDENT; (a)->qual = TM_TIME_QUAL_INCL;
             (a)->nsent = (a)->nrecd = 0; } }
static void rv_assign( RVALUE_TYPE *a, RVALUE_TYPE *b )
    { if((a)&&(b)) *(a) = *(b); }
static void rv_reduce( RVALUE_TYPE *a, RVALUE_TYPE *b)
    { if((a)&&(b))
        { if(TM_LT((b)->val, (a)->val) ||
             (TM_EQ((b)->val, (a)->val) && ((b)->qual < (a)->qual)) )
                 { (a)->val = (b)->val; (a)->qual = (b)->qual; }
          (a)->nsent += (b)->nsent; (a)->nrecd += (b)->nrecd; } }
static void rv_set( RVALUE_TYPE *a, TM_Time v, TM_TimeQual qual, int ns, int nr)
    { if(a) { (a)->val = v; (a)->qual = qual;
              (a)->nsent = ns; (a)->nrecd = nr; } }
static void rv_print( FILE *fp, RVALUE_TYPE *a )
    { if(!a) return;
      fprintf((fp), "<");
      if(TM_GE((a)->val,TM_IDENT)) fprintf((fp), "Infinity");
      else fprintf((fp),"%f (%s)", TM_TS((a)->val),TM_TIME_QUAL_STR((a)->qual));
      fprintf( (fp), ", %ld, %ld>", (a)->nsent, (a)->nrecd );
    }
/*----------------------------------------------------------------------------*/
static RVALUE_CLASS rv_class =
{
    rv_new, rv_delete, rv_init, rv_assign, rv_reduce, rv_print
};

/*----------------------------------------------------------------------------*/
enum { RM_START_MSG, RM_VALUE_MSG };

/*----------------------------------------------------------------------------*/
typedef struct TMMesgStruct
{
    long ssn;                  /*ID# of snapshot to which this mesg belongs*/
    long trial;                /*Trial number within this snapshot*/
    long type;                 /*Is it Start/Value message?*/
    long from_pe, to_pe;       /*From & To which processor?*/
        #if !PLATFORM_WIN
         long padding; /*Compatibility with size generated by Windows compiler*/
        #endif
    RVALUE_TYPE val;           /*If Value message, contains the value*/
    TM_Time old_lbts;          /*LBTS computed in previous snapshot/epoch*/
    TM_TimeQual old_qual;      /*LBTS qualification in previous snapshot/epoch*/
    struct TMMesgStruct *next; /*Scratch for linking msg buffers*/
} TMMesg;

/*----------------------------------------------------------------------------*/
#define hton_TMMesg(/*TMMesg **/m) \
    do{ \
        (m)->ssn = htonl((m)->ssn); \
        (m)->trial = htonl((m)->trial); \
        (m)->type = htonl((m)->type); \
        (m)->from_pe = htonl((m)->from_pe); \
        (m)->to_pe = htonl((m)->to_pe); \
        hton_RVALUE_TYPE(&(m)->val); \
        hton_TM_Time(&(m)->old_lbts); \
        hton_TM_TimeQual(&(m)->old_qual); \
    }while(0)
#define ntoh_TMMesg(/*TMMesg **/m) \
    do{ \
        (m)->ssn = ntohl((m)->ssn); \
        (m)->trial = ntohl((m)->trial); \
        (m)->type = ntohl((m)->type); \
        (m)->from_pe = ntohl((m)->from_pe); \
        (m)->to_pe = ntohl((m)->to_pe); \
        ntoh_RVALUE_TYPE(&(m)->val); \
        ntoh_TM_Time(&(m)->old_lbts); \
        ntoh_TM_TimeQual(&(m)->old_qual); \
    }while(0)

/*----------------------------------------------------------------------------*/
#if MPI_AVAILABLE
    #define USE_MPIALLREDUCE TRUE
#else /*MPI_AVAILABLE*/
    #define USE_MPIALLREDUCE FALSE
    #define MPI_DOUBLE 0
    #define MPI_MIN 0
    #define MPI_COMM_WORLD 0
    #define MPI_SUCCESS 0
    #define MPI_FAILURE -1
    #define MPI_Allreduce( _1, _2, _3, _4, _5, _6 ) MPI_FAILURE
#endif /*MPI_AVAILABLE*/
static int use_mpiallreduce = USE_MPIALLREDUCE;
#undef USE_MPIALLREDUCE

/*----------------------------------------------------------------------------*/
#if PORTALS_AVAILABLE
    #include "tmport.c"
    #define USE_PORTALS TRUE
#else /*PORTALS_AVAILABLE*/
    #define USE_PORTALS FALSE
    #define TMPTL_Init( _1, _2, _3, _4, _5 ) (void)0
    #define TMPTL_Finish(_1) (void)0
    #define TMPTL_RecvMesgs(_1,_2) (0)
    #define TMPTL_SendMesg(_1,_2, _3) (void)0
    #define TMPTL_FlushSends(_1) (void)0
#endif /*PORTALS_AVAILABLE*/
static int use_portals = USE_PORTALS;
#undef USE_PORTALS

/*----------------------------------------------------------------------------*/
typedef struct
{
    long ID;            /*Current epoch number (same as next snapshot ID)*/
    long nsent, nrecd;  /*Event counters for next (immediate) snapshot*/

    /*Special case data; see TMMRed_In()*/
    long next_id;       /*ID of next epoch*/
    long next_nrecd;    /*Number of incoming messages in the next epoch*/
} Epoch;

/*----------------------------------------------------------------------------*/
typedef struct
{
    int active;        /*Is this snapshot computation in progress now? */
    long ID;           /*Active (or most recently completed) snapshot number*/
    long trial;        /*Trial number within active snapshot computation*/
    RMUserHandle rh;   /*Handle for the reduction service*/
    RVALUE_TYPE value; /*Reduction value reported in currently active trial*/
    RVALUE_TYPE transients; /*Transient msgs of this snapshot accumulated here*/
    struct
    {
      int do_timeout;  /*Should timeouts be turned on or off?*/
      int counter;     /*#ticks so far, before starting to check timeout*/
      int max_count;   /*Start checking for timeout time after this many ticks*/
      TIMER_TYPE start;/*When did this snapshot computation start?*/
      double period;   /*Timeout this snapshot after this many seconds*/
    } timeout;
} Snapshot;

/*----------------------------------------------------------------------------*/
typedef struct
{
    TM_Time LBTS;           /*Most recently known value; updated via snapshots*/
    TM_TimeQual qual;       /*Qualification of recent LBTS; see TM_TimeQual*/
    TM_LBTSStartedProc sproc;/*Callback for getting this PE's snap shot value*/
    TM_LBTSDoneProc *dproc; /*List of callbacks waiting for new LBTS value*/
    int max_dproc;          /*Limit on #callbacks that can wait for new LBTS*/
    int n_dproc;            /*Actual #callbacks waiting for new LBTS*/
} LBTSInfo;

/*----------------------------------------------------------------------------*/
typedef struct
{
    unsigned int fmh;       /*FM handle ID*/
    int use_udp;            /*Should UDP used for TM messages?*/
    TMMesg *buffered_msgs;  /*Msgs for next epoch/trial, but arrived early*/
    TMMesg *free_msgs;      /*Free pool of message buffers*/
    double loss_prob;       /*Probability of losing any incoming TM message*/
    double msg_delay;       /*Average network latency for any TM message*/
} Communication;

/*----------------------------------------------------------------------------*/
typedef struct
{
    TIMER_TYPE start; /*When did TMMRed_Init() end?*/
    long nlbts;        /*Total number of LBTS computations so far*/
    struct
    {
        long max;      /*Max #trials per LBTS completion*/
        long tot;      /*Sum total of #trials across all LBTS computations*/
        long warnntrials; /*Print warning if #trails in an epoch exceeds this*/
        long abortntrials; /*Abort if #trails in an epoch exceeds this*/
        RVALUE_TYPE recentrv; /*Most recently computed reduction val*/
    } trial;
    struct /*Performance stats*/
    {
        TIMER_TYPE rstart; /*When started most recent LBTS*/
        TM_Time prev_lbts; /*Previous LBTS*/
        TM_Time locval; /*Local value contributed to current LBTS*/
        double wcsec_sum; /*Sum of wall clock secs taken by LBTSs so far*/
        double wcsecsq_sum; /*Sum of squares of wall clock secs...*/
        double simdt_sum; /*Sum of sim delta time between consecutive LBTSs*/
        double simdtsq_sum; /*Sum of squares of sim delta time ...*/
        int printeveryn; /*Every how many LBTS should status be printed*/
        long printlbtsmaxpe; /*Last pe+1 for which to print LBTS progress*/
    } perf;
} Statistics;

/*----------------------------------------------------------------------------*/
typedef struct
{
    int debug;              /*Debugging level*/
    int myid;               /*My processor ID*/
    int N;                  /*Total number of processors*/
    Epoch epoch;            /*Current (active) epoch information*/
    Snapshot sshot;         /*Active (or most recently completed) snapshot*/
    LBTSInfo lbts;          /*How LBTS values must be acquired/stored/reported*/
    Communication comm;     /*Message send/receive/buffer information*/
    Statistics stats;       /*Self-explanatory*/
} TMState;

/*----------------------------------------------------------------------------*/
/* Global TM state, and cached pointers into the global TM state              */
/* In multi-threaded implementation, pass TM state as argument to API calls,  */
/* and move the cached pointers into the functions (as local variables).      */
/*----------------------------------------------------------------------------*/
static TMState tm_state;
static TMState *st;
static Epoch *epoch;
static Snapshot *sshot;
static LBTSInfo *lbts;
static Communication *comm;
static Statistics *stats;

/*----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
static int recv_msg( FM_stream *strm, unsigned senderID );
static void send_start_msg( RMUserHandle usr, void *closure,
                            int from_pe, int to_pe, int to_slot );
static void send_value_msg( RMUserHandle usr, void *closure,
                            int from_pe, int to_pe, RVALUE_TYPE *v,int to_slot);
static void continue_active_reduction( void );
static int deliver_buffered_msgs( void );
static void move_to_next_sshot_trial( void );
static void printstats( void );
static void printstate( void );

/*----------------------------------------------------------------------------*/
static void TMMRed_Init(TMM_Closure closure, TMM_LBTSStartedProc sproc)
{
    char *dbgstr = getenv("TMRED_DEBUG");     /* Integer [1,inf] */
    char *lossstr= getenv("TMRED_LPROB");     /* Double  [0.0,1.0] */
    char *delaystr= getenv("TMRED_MSGDELAY"); /* Double  [0.0,inf] secs */
    char *useudpstr= getenv("TMRED_USEUDP");  /* String TRUE or FALSE */
    char *usempiallredstr= getenv("TMRED_USEMPIBC");  /* String TRUE or FALSE */
    char *useportalsstr= getenv("TMRED_USEPORTALS");  /* String TRUE or FALSE */
    char *warnntrialsstr= getenv("TMRED_WARNNTRIALS");  /* Integer [1,inf] */
    char *abortntrialsstr= getenv("TMRED_ABORTNTRIALS");  /* Integer [1,inf] */
    char *lbtseverynstr= getenv("TMRED_PRINTLBTSEVERYN");  /* Integer [1,inf] */
    char *lbtsprintmaxpestr=getenv("TMRED_PRINTLBTSLASTPE"); /*Integer [1,P]*/

    MYASSERT( closure == &tm_state, ("Closures should match") );

    st = &tm_state;
    epoch = &st->epoch;
    sshot = &st->sshot;
    lbts = &st->lbts;
    comm = &st->comm;
    stats = &st->stats;

    st->debug            = dbgstr?atoi(dbgstr):1;
    st->myid             = (int) FM_nodeid;
    st->N                = (int) FM_numnodes;

    epoch->ID            = 0;
    epoch->nsent         = 0;
    epoch->nrecd         = 0;
    epoch->next_id       = 1;
    epoch->next_nrecd    = 0;

    sshot->active        = FALSE;
    sshot->ID            = -1;
    sshot->trial         = -1;
    sshot->rh            = rm_register( st->N, st->myid, MAX_PE, &rv_class );

    sshot->timeout.do_timeout= TRUE;
    sshot->timeout.counter   = 0;
    sshot->timeout.max_count = 10;
    sshot->timeout.period    = 2.0; /*Updated later*/

    lbts->LBTS           = TM_ZERO;
    lbts->qual           = TM_TIME_QUAL_INCL;
    lbts->sproc          = sproc;
    lbts->max_dproc      = 1000;
    lbts->n_dproc        = 0;
    lbts->dproc          = (TM_LBTSDoneProc *)malloc(
                           sizeof(TM_LBTSDoneProc)*lbts->max_dproc);

    comm->fmh            = -1;
    comm->use_udp        = (useudpstr&&!strcmp(useudpstr,"TRUE"));
    comm->buffered_msgs  = 0;
    comm->free_msgs      = 0;
    comm->loss_prob      = lossstr?atof(lossstr):0.0;
    comm->msg_delay      = delaystr?atof(delaystr):0.5;

    if( comm->loss_prob <= 0 ) sshot->timeout.do_timeout = FALSE;

    stats->nlbts         = 0;
    stats->trial.max     = 0;
    stats->trial.tot     = 0;
    stats->trial.warnntrials = warnntrialsstr ? atoi(warnntrialsstr) : 10;
    stats->trial.abortntrials = abortntrialsstr ? atoi(abortntrialsstr) : 100;;
    rv_init( &stats->trial.recentrv );

    TIMER_NOW( stats->perf.rstart );
    stats->perf.prev_lbts = TM_ZERO;
    stats->perf.locval = TM_ZERO;
    stats->perf.wcsec_sum = 0;
    stats->perf.wcsecsq_sum = 0;
    stats->perf.simdt_sum = 0;
    stats->perf.simdtsq_sum = 0;
    stats->perf.printeveryn = lbtseverynstr ? atoi(lbtseverynstr) : 0;
    if( stats->perf.printeveryn <= 0 ) stats->perf.printeveryn = 0;
    stats->perf.printlbtsmaxpe = lbtsprintmaxpestr ? atoi(lbtsprintmaxpestr):1;

if(st->myid==0 && st->debug>=0){fprintf(tmfp,"%d: TMRed ntrials warn %ld abort %ld\n",st->myid,stats->trial.warnntrials,stats->trial.abortntrials);fflush(tmfp);}

    rv_init( &sshot->value );
    rv_init( &sshot->transients );

    FML_RegisterHandler( &comm->fmh, recv_msg );

    sshot->timeout.period = 2*(st->N-1)*comm->msg_delay;/*Worst case per trial*/

    use_mpiallreduce = usempiallredstr&&!strcmp(usempiallredstr,"TRUE");
    if( use_mpiallreduce )
    {
        #if !MPI_AVAILABLE
            MYASSERT( !use_mpiallreduce,
                      ("%d: TMRed MPI_Allreduce not available\n",st->myid) );
            use_mpiallreduce = FALSE;
        #else /*MPI_AVAILABLE*/
#if !NODEBUG
if(st->debug>=0){fprintf(tmfp,"%d: TMRed Using MPI_Allreduce\n",st->myid);fflush(tmfp);}
#endif
        #endif /*MPI_AVAILABLE*/
    }
    else
    {
#if !NODEBUG
if(st->debug>=0){fprintf(tmfp,"%d: TMRed MPI_Allreduce available but not used\n",st->myid);fflush(tmfp);}
#endif
    }

    FML_Barrier();

    use_portals = useportalsstr&&!strcmp(useportalsstr,"TRUE");
    if( use_portals )
    {
        #if !PORTALS_AVAILABLE
          MYASSERT(!use_portals,("%d: TMRed Portals not available\n",st->myid));
          use_portals = FALSE;
        #else /*PORTALS_AVAILABLE*/
          int max_vsend = 128, max_ssend = 256, max_vrecv = 128, max_srecv = 256; /*XXX CUSTOMIZE*/

#if !NODEBUG
if(st->debug>=0){fprintf(tmfp,"%d: TMRed Using Portals\n",st->myid);fflush(tmfp);}
#endif

          TMPTL_Init( st->myid, max_vsend, max_ssend, max_vrecv, max_srecv );

#if !NODEBUG
if(st->debug>=0){fprintf(tmfp,"%d: TMRed Portals initialized\n",st->myid);fflush(tmfp);}
#endif
          FML_Barrier();
        #endif /*PORTALS_AVAILABLE*/
    }
    else
    {
#if !NODEBUG
        #if PORTALS_AVAILABLE
if(st->debug>=0){fprintf(tmfp,"%d: TMRed Portals available but not used\n",st->myid);fflush(tmfp);}
        #else
if(st->debug>=0){fprintf(tmfp,"%d: TMRed Portals not available\n",st->myid);fflush(tmfp);}
        #endif
#endif
    }

    TIMER_NOW(stats->start);

    if(getenv("TMRED_UDPALWAYS")){FM_SetTransport(FM_TRANSPORT_UNRELIABLE);comm->use_udp=1;fprintf(tmfp,"--TMRED_UDPALWAYS---\n");fflush(tmfp);}

#if !NODEBUG
if(st->debug>=2){fprintf(tmfp,"-- PE %d: TMRED_LPROB=%g, TMRED_MSGDELAY=%g\n", st->myid, comm->loss_prob, comm->msg_delay);}
#endif

#if !NODEBUG
if(st->debug>=1){fprintf(tmfp,"%d: TMRed initialized.\n",st->myid);fflush(tmfp);}
#endif

    LSCFGLD( "TMRED_DEBUG", (long)st->debug,
             "TMRED debug intensity" );
    LSCFGST( "TMRED_USEMPIBC", (use_mpiallreduce?"TRUE":"FALSE"),
             "TMRED use MPI_Allreduce?" );
    LSCFGST( "TMRED_USEPORTALS", (use_portals?"TRUE":"FALSE"),
             "TMRED use portals?" );
    LSCFGLD( "TMRED_WARNNTRIALS", (long)stats->trial.warnntrials,
             "TMRED warn #trials" );
    LSCFGLD( "TMRED_ABORTNTRIALS", (long)stats->trial.abortntrials,
             "TMRED abort #trials" );
}

/*----------------------------------------------------------------------------*/
static void TMMRed_Fini(TMM_Closure closure)
{
#if !NODEBUG
if(st->debug>=1){fprintf(tmfp,"%d: TMRed finalizing.\n",st->myid);fflush(tmfp);}
#endif
    if( use_portals ) { TMPTL_Finish( st->myid ); }
#if !NODEBUG
if(st->debug>=1){fprintf(tmfp,"%d: TMRed finalized.\n",st->myid);fflush(tmfp);}
#endif
}

/*----------------------------------------------------------------------------*/
static void TMMRed_SetLBTSStartProc( TMM_Closure closure,
                TM_LBTSStartedProc started_proc )
{
    lbts->sproc = started_proc;
}

/*----------------------------------------------------------------------------*/
static long TMMRed_CurrentEpoch( TMM_Closure closure )
{
    return epoch->ID;
}

/*----------------------------------------------------------------------------*/
static void TMMRed_Recent_LBTS( TMM_Closure closure, TM_Time *pts )
{
    if( pts ) *pts = lbts->LBTS;
}

/*----------------------------------------------------------------------------*/
static long TMMRed_StartLBTSSnapShot( TM_Time min_ts, TM_TimeQual qual,
    TM_LBTSDoneProc done_proc, long *ptrans,
    long expected_sshot_id, long trial_num )
{
    static char tmstr1[1000],tmstr2[1000];
    MYASSERT( sshot->ID+1 == epoch->ID, ("!") );
    MYASSERT( TM_LE( lbts->LBTS, min_ts ),
                  ("%s %s", TM_STR(tmstr1,lbts->LBTS), TM_STR(tmstr1,min_ts)) );

    if( sshot->active )
    {
#if !NODEBUG
if(st->debug>2){fprintf(tmfp,"TMMRed_StartLBTSSnapShot(min_ts=%f,sshot-epoch=%ld,sshot-trial=%ld,curr-epoch=%ld)\n",TM_TS(min_ts),sshot->ID,sshot->trial,epoch->ID);}
#endif

        MYASSERT( sshot->ID+1 == epoch->ID,      ("!");printstate() );
        MYASSERT( sshot->ID+2 == epoch->next_id, ("!");printstate() );
    }
    else
    {
        /*Need to take a new snapshot and start reduction*/
        MYASSERT( expected_sshot_id == epoch->ID, ("!") );

        /*Transfer info from current epoch to snapshot, and prime reduction*/
        {
            TIMER_NOW( stats->perf.rstart );
            stats->perf.prev_lbts = lbts->LBTS;
            stats->perf.locval = min_ts;

            sshot->active = TRUE;
            sshot->ID = epoch->ID;
            sshot->trial = trial_num-1;
            rv_init( &sshot->value );
            rv_set(&sshot->transients, min_ts,qual, epoch->nsent, epoch->nrecd);
            move_to_next_sshot_trial();
        }

        /*Move to new epoch*/
        {
            MYASSERT( epoch->next_id == epoch->ID+1, ("!");printstate() );

            ++epoch->ID;
            epoch->nsent = 0;
            epoch->nrecd = epoch->next_nrecd;

            ++epoch->next_id;
            epoch->next_nrecd = 0;
        }
#if !NODEBUG
if(st->debug>1){fprintf(tmfp,"TMMRed_StartLBTSSnapShot(min_ts=%f,new-epoch=%ld)\n",TM_TS(min_ts),epoch->ID);}
#endif

        MYASSERT( lbts->n_dproc <= 0, ("!");printstate(); printstats() );
        lbts->n_dproc = 0; /*Clear current callbacks*/
    }

    MYASSERT( sshot->active, ("!") );
    if(0)/*XXX*/    MYASSERT( TM_LE( sshot->value.val, min_ts ),
              ("%lf %lf",TM_TS(sshot->value.val),TM_TS(min_ts)) );

    /*Add given procedure to the list of callbacks for the active computation*/
    if( done_proc )
    {
        MYASSERT( lbts->n_dproc < lbts->max_dproc, ("!") );
        lbts->dproc[lbts->n_dproc++] = done_proc;
    }

    if(ptrans) *ptrans = sshot->ID;

    return TM_SUCCESS;
}

/*----------------------------------------------------------------------------*/
static long TMMRed_StartLBTS( TMM_Closure closure,
                TM_Time min_ts, TM_TimeQual qual,
                TM_LBTSDoneProc done_proc, long *ptrans )
{
    return TMMRed_StartLBTSSnapShot(min_ts,qual,done_proc,ptrans,epoch->ID,0);
}

/*----------------------------------------------------------------------------*/
/*Used to start LBTS when it is inferred that a new epoch/LBTS must be started*/
/*----------------------------------------------------------------------------*/
static void remote_start_lbts( long sshot_id, long trial_num )
{
    TM_Time min_ts = TM_ZERO;
    TM_TimeQual qual = TM_TIME_QUAL_INCL;
    long sproc_flag;
    TM_LBTSDoneProc dproc;

#if !NODEBUG
if(st->debug>1){fprintf(tmfp,"**** Starting remotely initiated LBTS\n");}
if(st->debug>3){printstate();}
#endif

    MYASSERT( !sshot->active, ("!") );
    MYASSERT( lbts->sproc, ("!") );
    sproc_flag = lbts->sproc( epoch->ID, &min_ts, &qual, &dproc );
    if( sproc_flag == TM_DEFER ) { min_ts = lbts->LBTS; qual = lbts->qual; }
    TMMRed_StartLBTSSnapShot( min_ts, qual, dproc, NULL, sshot_id, trial_num );

#if !NODEBUG
if(st->debug>3){fprintf(tmfp,"**** Done starting remotely initiated LBTS.\n");}
if(st->debug>3){printstate();}
#endif
}

/*----------------------------------------------------------------------------*/
static void TMMRed_PutTag( TMM_Closure closure, char *ptag, int *nbytes )
{
    *((long *)ptag) = epoch->ID;
    *nbytes = sizeof(epoch->ID);
#if !NODEBUG
if(st->debug>1){fprintf(tmfp,"TMMRed_PutTag(epoch=%ld)\n",epoch->ID);}
#endif
}

/*----------------------------------------------------------------------------*/
static void TMMRed_Out( TMM_Closure closure, TM_Time ts, long nevents )
{
    epoch->nsent += nevents;
#if !NODEBUG
if(st->debug>1){fprintf(tmfp,"TMMRed_Out(ts=%f,nevents=%ld,epoch=%ld);epoch->nsent=%ld\n",TM_TS(ts),nevents,epoch->ID,epoch->nsent);}
#endif
}

/*----------------------------------------------------------------------------*/
static void TMMRed_In( TMM_Closure closure, TM_Time ts, char *ptag, int *nbytes)
{
    long epoch_id = *((long*)ptag);
    *nbytes = sizeof(epoch_id);

#if !NODEBUG
if(st->debug>1){fprintf(tmfp,"TMMRed_In(ts=%f,epoch=%ld,curr-epoch=%ld)\n",TM_TS(ts),epoch_id,epoch->ID);}
#endif

    if( epoch_id == epoch->ID )
    {
#if !NODEBUG
if(st->debug>2){fprintf(tmfp,"IncomingRegularMsg(ts=%f,epoch=%ld)\n",TM_TS(ts),epoch_id);}
#endif
        /*Belongs to current epoch*/
        ++epoch->nrecd;
    }
    else if( !sshot->active && epoch_id < epoch->ID )
    {
#if !NODEBUG
if(st->debug>1){fprintf(tmfp,"IncomingOldMsg(ts=%f,epoch=%ld)\n",TM_TS(ts),epoch_id);}
#endif

        /* Ignore this message -- this is possible in the case in which  */
        /* TSO messages can be lost; TM will try to advance LBTS even if */
        /* some transient messages are still not received, after waiting */
        /* for a while for those messages. */

        /* The RTI should drop this message on the floor, because this */
        /* message was presumed lost in the earlier LBTS computation */
    }
    else if( sshot->active && epoch_id == sshot->ID )
    {
        RVALUE_TYPE transient_msg;
        rv_set( &transient_msg, ts, TM_TIME_QUAL_INCL, 0, 1 );
        rv_reduce( &sshot->transients, &transient_msg );
#if !NODEBUG
if(st->debug>2){fprintf(tmfp,"IncomingTransientMsg(ts=%f,epoch=%ld)\n",TM_TS(ts),epoch_id);}
#endif
    }
    else if( epoch_id == epoch->ID+1 )
    {
        if( sshot->active )
        {
#if !NODEBUG
if(st->debug>1){fprintf(tmfp,"Future epoch; must buffer info.\n");printstate();}
#endif

            MYASSERT( epoch_id == epoch->next_id, ("!");printstate() );
            MYASSERT( epoch_id == sshot->ID+2,    ("!");printstate() );

            ++epoch->next_nrecd;
        }
        else
        {
#if !NODEBUG
if(st->debug>2){fprintf(tmfp,"Future epoch; must start new LBTS.\n");printstate();}
#endif

            /*Start a new epoch+snapshot at this processor*/
            remote_start_lbts( epoch->ID, 0 );

            MYASSERT( sshot->active, ("!");printstate() );
            MYASSERT( epoch_id == epoch->ID, ("!");printstate() );

            /*NOW, we have made sure this mesg belongs to current epoch!*/
            ++epoch->nrecd;
        }
    }
    else
    {
        MYASSERT(FALSE,("TMMRed_In:Unexpected epoch %ld\n",epoch_id);printstate());
    }
}

/*----------------------------------------------------------------------------*/
static int tot_tm_msgs, nlost_tm_msgs;

/*----------------------------------------------------------------------------*/
static void printstats( void )
{
    TIMER_TYPE stop;
    double secs;

    TIMER_NOW(stop);
    secs = TIMER_DIFF(stop, stats->start);

    fprintf(tmfp,"%d: TMMRED-Stastics\n",st->myid);
    fprintf(tmfp,"%d: ---------------------------\n",st->myid);
    fprintf(tmfp,"%d: NEpochs=             %ld\n",st->myid, epoch->ID-1);
    fprintf(tmfp,"%d: NLBTS=               %ld\n",st->myid, stats->nlbts);
    fprintf(tmfp,"%d: Tot-trials=          %ld\n",st->myid, stats->trial.tot);
    fprintf(tmfp,"%d: Max-trials-per-LBTS= %ld\n",st->myid, stats->trial.max);
    fprintf(tmfp,"%d: Avg-trials-per-LBTS= %g\n",st->myid,((double)stats->trial.tot)/stats->nlbts);
    fprintf(tmfp,"%d: Time-per-trial=      %16.8f microsecs\n",st->myid,secs/stats->trial.tot*1e6);
    fprintf(tmfp,"%d: Time-per-LBTS=       %16.8f microsecs\n",st->myid, secs/stats->nlbts*1e6);
    fprintf(tmfp,"%d: NLBTS-per-sec=       %16.8f\n",st->myid, stats->nlbts/secs);
    fprintf(tmfp,"%d: ---------------------------\n",st->myid);

    if(nlost_tm_msgs>0)fprintf(tmfp, "%d: Total TM messages = %d, lost = %d, P(loss) = %g\n",st->myid, tot_tm_msgs, nlost_tm_msgs, nlost_tm_msgs/(double)tot_tm_msgs );
}

/*----------------------------------------------------------------------------*/
static void TMMRed_PrintStats( TMM_Closure closure ) { printstats(); }

/*----------------------------------------------------------------------------*/
static void print_tm_mesg(FILE *fp, TMMesg *m)
{
    fprintf(fp, "{ssn=%ld, trial=%ld, type=%ld, from_pe=%ld, to_pe=%ld, val=",
            m->ssn, m->trial, m->type, m->from_pe, m->to_pe);
    rv_print( fp, &m->val );
    fprintf(fp, ", old_lbts=%f, next=%p}", TM_TS(m->old_lbts), m->next);
}

/*----------------------------------------------------------------------------*/
static void printstate( void )
{
    int i = 0;

    fprintf(tmfp,"------------  TMMRED STATE START ------------\n");
    fprintf(tmfp,"myid=%d, N=%d\n", st->myid, st->N);

    fprintf(tmfp,"Epoch={ID=%ld, nsent=%ld, nrecd=%ld, next_id=%ld, next_nrecd=%ld}\n",
           epoch->ID, epoch->nsent, epoch->nrecd,
           epoch->next_id, epoch->next_nrecd);

    fprintf(tmfp,"Snapshot={active=%d, ID=%ld, trial=%ld, rh=%p, ",
           sshot->active, sshot->ID, sshot->trial, sshot->rh);
    fprintf(tmfp,"value="); rv_print(tmfp, &sshot->value); fprintf(tmfp,", ");
    fprintf(tmfp,"transients="); rv_print(tmfp, &sshot->transients);
    fprintf(tmfp,"timeout{do_timeout=%s, counter=%d, max_count=%d, period=%f secs} ",
           (sshot->timeout.do_timeout ? "TRUE" : "FALSE"),
           sshot->timeout.counter, sshot->timeout.max_count,
           sshot->timeout.period);
    fprintf(tmfp,"}\n");

    fprintf(tmfp,"LBTS={LBTS=%f (%s) sproc=%p, max_dproc=%d, n_dproc=%d, dproc=[",
           TM_TS(lbts->LBTS), TM_TIME_QUAL_STR(lbts->qual),
           lbts->sproc, lbts->max_dproc, lbts->n_dproc);
    for(i=0; i<lbts->n_dproc; i++) fprintf(tmfp,"%s%p", (i>0?",":"!"),lbts->dproc[i]);
    fprintf(tmfp,"]}\n");

    fprintf(tmfp,"Comm={fmh=%d, use_udp=%s, buffered_msgs=%p, free_msgs=%p"
           ", loss_prob=%f, msg_delay=%f secs}\n",
           comm->fmh, comm->use_udp?"TRUE":"FALSE",
           comm->buffered_msgs, comm->free_msgs,
           comm->loss_prob, comm->msg_delay);
    {
      TMMesg *m=comm->buffered_msgs;
      while(m){fprintf(tmfp,"\t");print_tm_mesg(tmfp,m);fprintf(tmfp,"\n");m=m->next;}
    }

    fprintf(tmfp,"Stats={nlbts=%ld, trial{max=%ld,tot=%ld,warnn=%ld,abortn=%ld}}\n",
           stats->nlbts, stats->trial.max, stats->trial.tot,
           stats->trial.warnntrials, stats->trial.abortntrials);
    fprintf(tmfp,"recentrv=");rv_print(tmfp, &stats->trial.recentrv);fprintf(tmfp,"}}\n");
    fprintf(tmfp,"------------  TMMRED STATE END ------------\n");
}

/*----------------------------------------------------------------------------*/
static void TMMRed_PrintState( TMM_Closure closure ) { printstate(); }

/*----------------------------------------------------------------------------*/
static void enqueue_msg( const TMMesg *pmsg );
static void tmptl_recv_callback( const TMMesg *pmsg )
{
    enqueue_msg( pmsg );
}

/*----------------------------------------------------------------------------*/
static void TMMRed_Tick( TMM_Closure closure )
{
    int ndelivered = 0;
    if( use_portals ) { TMPTL_RecvMesgs( st->myid, tmptl_recv_callback ); }
    do
    {
        continue_active_reduction();
if( lbts->n_dproc <= 0 ) ndelivered = 0; else/*XXX*/
        ndelivered = deliver_buffered_msgs();
    }while(ndelivered > 0);
}

/*----------------------------------------------------------------------------*/
static void TMMRed_NotifyNewLBTS(TMM_Closure closure, TM_Time ts,TM_TimeQual q)
{
    /*XXX TBC*/
}

/*----------------------------------------------------------------------------*/
static void update_trial_stats( void )
{
    ++stats->trial.tot;
    if(sshot->trial+1 > stats->trial.max) {stats->trial.max = sshot->trial+1;}

if(sshot->trial+1 >= stats->trial.warnntrials) {printstate(); fprintf(tmfp,"WARNING: Large #trials %ld in an epoch\n\n\n", sshot->trial+1); fflush(tmfp);} /*XXX*/
if(sshot->trial+1 >= stats->trial.abortntrials) {printstate(); fprintf(tmfp,"ABORTING: Preventive termination due to too many trials %ld in an epoch\n\n\n", sshot->trial+1); fflush(tmfp); exit(1);} /*XXX*/
}

/*----------------------------------------------------------------------------*/
static void move_to_next_sshot_trial( void )
{
    MYASSERT( sshot->active, ("!") );

    ++sshot->trial;
    rv_reduce( &sshot->value, &sshot->transients ); /*Update value*/
    rv_init( &sshot->transients ); /*Reset*/

    if( sshot->timeout.do_timeout )
    {
        sshot->timeout.counter = 0;
        TIMER_NOW( sshot->timeout.start );
    }

    update_trial_stats();

    rm_init( sshot->rh, RM_SCHEDULE_GROUPED_BFLY );
    rm_receive_value( sshot->rh, st->myid, &sshot->value );
}

/*----------------------------------------------------------------------------*/
static void terminate_active_sshot( TM_Time new_lbts, TM_TimeQual new_qual )
{
    MYASSERT( sshot->active, ("!") );
    MYASSERT( TM_LE( lbts->LBTS, new_lbts ),
              ("LBTS %lf must not decrease to %lf.",
              TM_TS(lbts->LBTS),TM_TS(new_lbts)) );

    sshot->active = FALSE;
    lbts->LBTS = new_lbts;
    lbts->qual = new_qual;

    /*Track the rate of progress*/
    if( lbts->LBTS.ts < 1e37 ) /*Don't count the very large leap at endtime*/
    {
        double wcdt, simdt;
        TIMER_TYPE t2;
        TIMER_NOW( t2 );
        wcdt = TIMER_DIFF( t2, stats->perf.rstart );
        simdt = (lbts->LBTS.ts - stats->perf.prev_lbts.ts);
        stats->perf.wcsec_sum += wcdt;
        stats->perf.wcsecsq_sum += wcdt*wcdt;
        stats->perf.simdt_sum += simdt;
        stats->perf.simdtsq_sum += simdt*simdt;

        if( (st->myid < stats->perf.printlbtsmaxpe) &&
            (stats->perf.printeveryn > 0) &&
            ((stats->nlbts % stats->perf.printeveryn) == 0) )
        {
          fprintf(tmfp, "LBTSPROGRESS: NLBTS= %10ld WCDT= %8.2lf us SIMDT= %12.6lf",
                  stats->nlbts+1, wcdt*1e6, simdt );
          fprintf(tmfp, " PREVLBTS= %12.6lf LBTS= %12.6lf",
                  stats->perf.prev_lbts.ts, lbts->LBTS.ts );
          fprintf(tmfp, " AVGWCDT= %8.2lf us AVGSIMDT= %12.6lf",
                  stats->perf.wcsec_sum/(stats->nlbts+1)*1e6,
                  stats->perf.simdt_sum/(stats->nlbts+1) );
          fprintf(tmfp, " TOTWC= %8.2lf us LOCSIMVAL= %12.6lf",
                  stats->perf.wcsec_sum*1e6, stats->perf.locval.ts );
          fprintf(tmfp, "\n" );
          fflush(tmfp);
        }
    }

    /*Report to waiting callbacks*/
    {
        int c;
        for( c = 0; c < lbts->n_dproc; c++ )
        {
            lbts->dproc[c]( lbts->LBTS, lbts->qual, sshot->ID );
        }
        lbts->n_dproc = 0;
    }

    ++stats->nlbts;
}

/*----------------------------------------------------------------------------*/
static void continue_active_reduction( void )
{
    if( sshot->active )
    {
        RVALUE_TYPE dval;
        int timedout = FALSE;
        int done=0;

        if( use_mpiallreduce )
        {
            int inx = sshot->value.nrecd - sshot->value.nsent, outx = 0;
            int retcode =
              MPI_Allreduce( &inx, &outx, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD );
            MYASSERT( retcode == MPI_SUCCESS, ("MPI_Allreduce") );
            dval.val.ts = 0;
            dval.val.tie = 0;
            dval.nsent = outx;
            dval.nrecd = 0;
            if( outx == 0 )
            {
                int retcode2 =
                  MPI_Allreduce( &sshot->value.val.ts, &dval.val.ts, 1,
                                 MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD );
                dval.val.tie = sshot->value.val.tie;/*XXX A HACK (INCORRECT)*/
                MYASSERT( retcode == MPI_SUCCESS, ("MPI_Allreduce2") );
            }
            done = TRUE;
        }
        else
        {
            done=rm_resume(sshot->rh, &dval, send_start_msg, send_value_msg, 0);
            if( done && use_portals ) { TMPTL_FlushSends(st->myid); }
        }

        /*Check if trial's taking too long (i.e.must be timedout?)*/
        if( !done && sshot->timeout.do_timeout )
        {
            /*Performance opt: Poll the timer only after several initial ticks*/
            if( sshot->timeout.counter < sshot->timeout.max_count )
            {
                ++sshot->timeout.counter;
            }
            else
            {
                TIMER_TYPE now;
                TIMER_NOW(now);
                if( TIMER_DIFF( now, sshot->timeout.start ) >
                    sshot->timeout.period )
                {
                    /*This trial is timedout*/
                    timedout = TRUE;
                }
            }
        }

        if( done || timedout ) /*Current trial done or timedout*/
        {
#if !NODEBUG
if(st->debug>0){fprintf(tmfp,"TMMRed: %s snapshot %ld trial %ld: ",(done?"Done":"Timedout"),sshot->ID,sshot->trial);rv_print(tmfp,&dval); fprintf(tmfp,"\n"); fflush(tmfp);}
if(st->debug>2){printstate();}
#endif

            if( done && (dval.nsent == dval.nrecd) ) /*Current snapshot done!*/
            {
                terminate_active_sshot( dval.val, dval.qual );
            }
            else /*Snapshot incomplete or timedout; start next trial*/
            {
                rv_assign( &stats->trial.recentrv, &dval );
                move_to_next_sshot_trial();
            }
        }
    }
}

/*----------------------------------------------------------------------------*/
static int deliver_buffered_msgs( void )
{
    TMMesg **b = &comm->buffered_msgs;
    int ndelivered = 0;

    while( *b )
    {
        TMMesg *msg = *b;
        int deliver = FALSE, consume = TRUE;

        if( sshot->active )
        {
            if( msg->ssn == sshot->ID )
            {
                if( msg->trial == sshot->trial )
                {
                    deliver = TRUE;
                }
                else
                {
                    if( msg->trial < sshot->trial )
                    {
                        /*Ignore outdated msg*/
                    }
                    else
                    {
                        /*Future message; retain in queue*/
                        consume = FALSE;
                    }
                }
            }
            else
            {
                if( msg->ssn < sshot->ID )
                {
                    /*Ignore outdated msg*/
                }
                else /*This must be a Start/Value msg from next epoch*/
                {
                    MYASSERT( msg->ssn==sshot->ID+1, ("Must be of next epoch"));

                    /*No point continuing currently active snapshot*/
                    /*since we have the LBTS as sent by the neighbor PE!*/

#if !NODEBUG
if(st->debug>1){fprintf(tmfp,"!!------------ Skipping currently active snapshot!\n");fprintf(tmfp,"Recd msg:");print_tm_mesg(tmfp,msg);fprintf(tmfp,"\n");printstate();}
#endif

                    if( sshot->timeout.do_timeout )
                    terminate_active_sshot( msg->old_lbts, msg->old_qual );

                    /*Future message; retain in queue*/
                    consume = FALSE;
                }
            }
        }
        else
        {
            if( msg->ssn == epoch->ID )
            {
                /*Take new snapshot and start LBTS computation*/
                remote_start_lbts( msg->ssn, msg->trial );

                MYASSERT( sshot->active &&
                        msg->ssn == sshot->ID &&
                        msg->trial == sshot->trial,
                        ("!");print_tm_mesg(stderr,msg);printstate() );

                deliver = TRUE; /*And, deliver this msg to new reduction*/
            }
            else
            {
                if( msg->ssn < epoch->ID )
                {
                    /*Ignore outdated msg*/
                }
                else
                {
                    /*Future message; retain in queue*/
                    consume = FALSE;
                }
            }
        }

        if( deliver )
        {
            MYASSERT(msg->ssn == sshot->ID && msg->trial == sshot->trial,("!"));
            switch( msg->type )
            {
                case RM_START_MSG:
                {
                    rm_receive_start( sshot->rh, msg->from_pe );
                    break;
                }
                case RM_VALUE_MSG:
                {
                    rm_receive_value( sshot->rh, msg->from_pe, &msg->val );
                    break;
                }
                default:
                {
                    MYASSERT( FALSE, ("!") ); /*Unknown type*/
                    break;
                }
            }
            ndelivered++;
        }

        if( consume )
        {
#if !NODEBUG
if(st->debug>3){fprintf(tmfp,"Consuming msg:");print_tm_mesg(tmfp,msg);fprintf(tmfp,"\n");}
#endif
            { *b = msg->next; }
            { msg->next = comm->free_msgs; comm->free_msgs = msg; }
        }
        else /*retain msg in queue*/
        {
#if !NODEBUG
if(st->debug>3){fprintf(tmfp,"Retaining msg:");print_tm_mesg(tmfp,msg);fprintf(tmfp,"\n");}
#endif
            { b = &((*b)->next); }
        }
    }
#if !NODEBUG
if(st->debug>4) if(ndelivered>0) {fprintf(tmfp,"+++ Delivered %d msgs\n",ndelivered);printstate();}
#endif

    return ndelivered;
}

/*----------------------------------------------------------------------------*/
static void send_msg( TMMesg *msg, int to_slot )
{
    FM_stream *strm = 0;
    FM_Transport prev_transport;

    MYASSERT( sshot->active, ("!") );

    msg->ssn = sshot->ID; msg->trial = sshot->trial;
    msg->old_lbts = lbts->LBTS;
    msg->old_qual = lbts->qual;

    if( use_portals )
    {
        TMPTL_SendMesg( st->myid, msg, to_slot );
    }
    else
    {
        prev_transport = FM_GetTransport();
        FM_SetTransport( comm->use_udp ?
                         FM_TRANSPORT_UNRELIABLE : FM_TRANSPORT_RELIABLE );

        strm = FM_begin_message( msg->to_pe, sizeof(TMMesg), comm->fmh );
        hton_TMMesg( msg );
        FM_send_piece( strm, msg, sizeof(*msg) );
        FM_end_message( strm );

        FM_SetTransport( prev_transport );
    }
}

/*----------------------------------------------------------------------------*/
static void send_start_msg( RMUserHandle usr, void *closure,
    int from_pe, int to_pe, int to_slot )
{
    TMMesg msg;
    msg.type = RM_START_MSG; msg.from_pe = from_pe; msg.to_pe = to_pe;
    rv_init( &msg.val );
    send_msg( &msg, to_slot );
}

/*----------------------------------------------------------------------------*/
static void send_value_msg( RMUserHandle usr, void *closure,
    int from_pe, int to_pe, RVALUE_TYPE *v, int to_slot )
{
    TMMesg msg;
    msg.type = RM_VALUE_MSG; msg.from_pe = from_pe; msg.to_pe = to_pe;
    rv_assign( &msg.val, v );
    send_msg( &msg, to_slot );
}

/*----------------------------------------------------------------------------*/
static TMMesg *allocate_free_msgs( int nmsgs )
{
    int i = 0;
    TMMesg *first = 0, **b = &first;
    for( i = 0; i < nmsgs; i++ )
    {
        *b = (TMMesg *)malloc( sizeof(TMMesg) );
        if( *b ) { b = &((*b)->next); *b = 0; }
    }
    if(st->debug)fprintf(tmfp,"Allocated %d free TM buffers.\n",nmsgs);
    return first;
}

/*----------------------------------------------------------------------------*/
static void enqueue_msg( const TMMesg *pmsg )
{
    TMMesg msg = *pmsg;

#if !NODEBUG
if(st->debug>2){fprintf(tmfp,"recv_msg: "); print_tm_mesg(tmfp,&msg); fprintf(tmfp,"\n");}
#endif

    if( sshot->active && msg.ssn != sshot->ID ) /*Debugging/Testing*/
    {
#if !NODEBUG
if(st->debug>0){fprintf(tmfp,"***Type %ld ID mismatch: %ld %s %ld\n", msg.type, msg.ssn, ((msg.ssn < sshot->ID)?"<":">"), sshot->ID);}
#endif
    }

    ++tot_tm_msgs;

    if( !(0<=msg.from_pe && msg.from_pe<st->N &&
          0<=msg.to_pe && msg.to_pe<st->N &&
          msg.to_pe == st->myid &&
          (msg.type==RM_START_MSG || msg.type==RM_VALUE_MSG)) )
    {
        fprintf(tmfp, "***TM error on read: %ld, %ld\n", msg.from_pe, msg.to_pe );
    }
    else
    if(FALSE&&(comm->loss_prob>0.0)&&((rand()%((int)(1/comm->loss_prob)))==0))/*XXX*/
    {
#if !NODEBUG
if(st->debug>0){fprintf(tmfp,"Dropped TM mesg:");print_tm_mesg(tmfp,&msg);fprintf(tmfp,"\n");}
#endif
        nlost_tm_msgs++;
    }
    else
    {
        /*Buffer this message*/
        TMMesg *mbuf = 0;

        /*Get a free buffer and copy the contents to it*/
        {
            if( !comm->free_msgs )
                comm->free_msgs = allocate_free_msgs(100);
            MYASSERT( comm->free_msgs, ("!") );
            mbuf = comm->free_msgs;
            comm->free_msgs = mbuf->next;

            *mbuf = msg;
        }

        /*Append to queue*/
        {
            TMMesg **b = &comm->buffered_msgs;
            while(*b) b = &((*b)->next);
            *b = mbuf;
            mbuf->next = 0;
        }
    }
}

/*----------------------------------------------------------------------------*/
static int recv_msg( FM_stream *strm, unsigned senderID )
{
    TMMesg msg;

    FM_receive( &msg, strm, sizeof(msg) );
    ntoh_TMMesg( &msg );

    enqueue_msg( &msg );

    return FM_CONTINUE;
}

/*----------------------------------------------------------------------------*/
void TMMRed_AddModule( void )
{
    TMModule mod = {
        &tm_state,
        TMMRed_Init,
        TMMRed_Fini,
        TMMRed_CurrentEpoch,
        TMMRed_Recent_LBTS,
        TMMRed_StartLBTS,
        TMMRed_PutTag,
        TMMRed_Out,
        TMMRed_In,
        TMMRed_PrintStats,
        TMMRed_PrintState,
        TMMRed_Tick,
        TMMRed_NotifyNewLBTS
    };

    TM_AddModule( &mod );
}

/*----------------------------------------------------------------------------*/
